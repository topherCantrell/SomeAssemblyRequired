'{$STAMP BS2}

' Simple command protocol
' 1 - Set delay [MSB,LSB]
' 2 - Send byte [BYTE]
' 3 - Read byte [BYTE sent to host]

CLOCK_PIN     con 15   ' Clock to drive the data movement
DATA_0_PIN    con  0   ' Data-bit 0
DATA_1_PIN    con  1   ' Data-bit 1

value var byte         ' Byte-value to send to target
delay var word         ' Milliseconds after clock
cnt   var byte

  low CLOCK_PIN    ' Initialize ...
  low DATA_0_PIN   ' ... outputs ...
  low DATA_1_PIN   ' ... to 0

  delay = 1000

main:


  gosub ReadByteFromHost
  IF(value = 65) then main_sendStatus
  IF(value = 66) then main_setDelay
  IF(value = 67) then main_sendByte
  IF(value = 68) then main_readByte
  goto main

main_sendStatus:
  serout 16,84,["READY"]
  value = 33
  gosub SendByteToHost
  goto main  

main_setDelay:
  gosub ReadByteFromHost
  delay = value
  gosub ReadByteFromHost
  delay = delay*256+value
  value = 33
  gosub SendByteToHost
  goto main

main_sendByte:
  gosub ReadByteFromHost
  gosub SendByte  
  value = 33
  gosub SendByteToHost
  goto main

main_readByte:
  gosub ReadByte
  gosub SendByteToHost
  value = 33
  gosub SendByteToHost
  goto main
  
' ==========================================================
' Read a single byte from the host
' ==========================================================

ReadByteFromHost:
   serin 16,84,[value]
   return

' ==========================================================
' Send a single byte to the host
' ==========================================================

SendByteToHost:
   serout 16,84,[value]
   return

' ==========================================================
' Send the byte in "value" 2 bits at a time pausing for
' "delay" milliseconds between each 2-bit set
' ==========================================================
 
SendByte:
 
   low DATA_0_PIN
   low DATA_1_PIN
   IF (value&64) = 0 then SB_1
   high DATA_0_PIN
SB_1:
   IF (value&128) = 0 then SB_2
   high DATA_1_PIN
SB_2:
   high CLOCK_PIN   
   'debug "Clock high",CR
   pause delay

   low DATA_0_PIN
   low DATA_1_PIN
   IF (value&16) = 0 then SB_3
   high DATA_0_PIN
SB_3:
   IF (value&32) = 0 then SB_4
   high DATA_1_PIN
SB_4:
   low CLOCK_PIN
   'debug "Clock low",CR
   pause delay

   low DATA_0_PIN
   low DATA_1_PIN
   IF (value&4) = 0 then SB_5
   high DATA_0_PIN
SB_5:
   IF (value&8) = 0 then SB_6
   high DATA_1_PIN
SB_6:
   high CLOCK_PIN
   'debug "Clock high",CR
   pause delay

   low DATA_0_PIN
   low DATA_1_PIN
   IF (value&1) = 0 then SB_7
   high DATA_0_PIN
SB_7:
   IF (value&2) = 0 then SB_8
   high DATA_1_PIN
SB_8:

   low CLOCK_PIN
   'debug "Clock low",CR
   pause delay

   return

' ==========================================================
' Read the byte to "value" 1 bit at a time pausing for
' "delay" milliseconds between each 1-bit set
' ==========================================================

ReadByte:

  value = 0
  cnt = 4

RB_0:
  pause delay
  value = value * 2
  IF (IN8 = 0) then RB_1
  value = value | 1
RB_1:
  high CLOCK_PIN

  pause delay
  value = value * 2
  IF (IN8 = 0) then RB_2
  value = value | 1
RB_2:
  low CLOCK_PIN
  cnt = cnt -1
  IF (cnt>0) then RB_0
  return
